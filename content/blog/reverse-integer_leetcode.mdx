---
title: Reverse Integer
description: Solve the "Reverse Integer" problem efficiently using Go.
tags: ["leetcode", "golang", "algorithms"]
date: "2024-09-28"
---

## Problem Statement

Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range \([-2^{31}, 2^{31} - 1]\), then return `0`.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

### Example 1:
**Input:** `x = 123`  
**Output:** `321`

### Example 2:
**Input:** `x = -123`  
**Output:** `-321`

### Example 3:
**Input:** `x = 120`  
**Output:** `21`

### Constraints:
- \(-2^{31} \leq x \leq 2^{31} - 1\)

## Approach

To solve this problem, we can follow these steps:
1. **Handle Edge Cases**: Check if the input integer is `0` since the reverse of `0` is `0`.
2. **Reversing Digits**: Use a loop to extract digits from the integer and build the reversed integer.
3. **Overflow Check**: Before appending each digit, check if the resulting integer would overflow the 32-bit integer limit.

### Algorithm
1. Initialize a variable `res` to store the reversed integer as an `int64` to handle overflow checking.
2. Extract the last digit of `x` using the modulo operator.
3. Update `res` by multiplying the current value by `10` and adding the extracted digit.
4. Check for overflow conditions after each update of `res`.
5. Reduce `x` by dividing it by `10`.
6. Continue until all digits have been processed.
7. If no overflow occurs, return the final result as an `int`.

### Flowchart
![Flowchart of Reverse Integer](/leetcode/reverse_integer.png)



### Implementation in Go

Here's how you can implement this algorithm in Go:

```go
package main

import (
	"math"
	"fmt"
)

// reverse reverses the digits of the integer x
func reverse(x int) int {
	if x == 0 {
		return 0
	}
	var res int64
	for x != 0 {
		res = res*10 + int64(x%10)
		if res > math.MaxInt32 || res < math.MinInt32 {
			return 0
		}
		x /= 10
	}
	return int(res)
}

func main() {
	fmt.Println(reverse(123))   // Output: 321
	fmt.Println(reverse(-123))  // Output: -321
	fmt.Println(reverse(120))   // Output: 21
	fmt.Println(reverse(0))     // Output: 0
}

```

### Explanation
1. The function starts by checking if the input x is 0. If so, it returns 0.
A loop runs as long as x is not 0, extracting the last digit and building the reversed number.
2. The check for overflow is done using the math.MaxInt32 and math.MinInt32 constants to ensure that the resulting value fits within the 32-bit signed integer range.
3. The extracted digits are accumulated in res which is declared as an int64 to prevent overflow during the accumulation process.

## Conclusion
This approach effectively reverses the digits of a signed 32-bit integer while handling potential overflow issues. The solution efficiently utilizes basic arithmetic operations and control structures to achieve the desired result.