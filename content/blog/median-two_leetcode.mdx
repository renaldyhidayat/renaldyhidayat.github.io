---
title: Median of Two Sorted Arrays
description: Solve the "Median of Two Sorted Arrays" problem efficiently using binary search in Go.
tags: ["leetcode", "golang", "algorithms"]
date: "2024-09-28"
---

## Problem Statement

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the **median** of the two sorted arrays. The overall run-time complexity should be O(log (m+n)).

### Example 1:

- **Input**: `nums1 = [1, 3]`, `nums2 = [2]`
- **Output**: `2.00000`
- **Explanation**: Merged array = `[1, 2, 3]`, and the median is `2`.

### Example 2:

- **Input**: `nums1 = [1, 2]`, `nums2 = [3, 4]`
- **Output**: `2.50000`
- **Explanation**: Merged array = `[1, 2, 3, 4]`, and the median is `(2 + 3) / 2 = 2.5`.

## Approach

To solve the problem in O(log(m+n)) time complexity, we can avoid merging the two arrays and instead perform a **binary search**. The key idea is to partition the arrays such that the left half contains smaller or equal elements, and the right half contains larger elements.

### Algorithm

1. Ensure that `nums1` is the smaller of the two arrays (this makes the binary search range smaller).
2. Use binary search on the smaller array `nums1`. We are trying to find a partition such that:
   - Elements to the left of the partition in `nums1` and `nums2` are less than or equal to elements on the right.
3. For each partition, check if it satisfies the conditions to calculate the median:
   - If valid, the median is the average of the maximum element from the left half and the minimum element from the right half (for even total length). If odd, it's just the maximum element from the left half.

### Flowchart
![Flowchart of Median Two](/leetcode/median_two.png)



### Implementation in Go

Here's the implementation of the solution using binary search:

```go
package main

import "fmt"

// FindMedianSortedArray finds the median of two sorted arrays
func FindMedianSortedArray(nums1 []int, nums2 []int) float64 {
	if len(nums1) > len(nums2) {
		return FindMedianSortedArray(nums2, nums1) // Ensure nums1 is the smaller array
	}

	low, high := 0, len(nums1)
	k := (len(nums1) + len(nums2) + 1) >> 1 // Midpoint calculation

	var nums1Mid, nums2Mid int

	for low <= high {
		nums1Mid = low + (high-low)>>1
		nums2Mid = k - nums1Mid

		// Adjust binary search boundaries
		if nums1Mid > 0 && nums1[nums1Mid-1] > nums2[nums2Mid] {
			high = nums1Mid - 1
		} else if nums1Mid != len(nums1) && nums1[nums1Mid] < nums2[nums2Mid-1] {
			low = nums1Mid + 1
		} else {
			break
		}
	}

	// Finding midLeft and midRight
	var midLeft, midRight int
	if nums1Mid == 0 {
		midLeft = nums2[nums2Mid-1]
	} else if nums2Mid == 0 {
		midLeft = nums1[nums1Mid-1]
	} else {
		midLeft = Max(nums1[nums1Mid-1], nums2[nums2Mid-1])
	}

	if (len(nums1)+len(nums2))%2 == 1 {
		return float64(midLeft) // Odd number of elements, median is midLeft
	}

	if nums1Mid == len(nums1) {
		midRight = nums2[nums2Mid]
	} else if nums2Mid == len(nums2) {
		midRight = nums1[nums1Mid]
	} else {
		midRight = Min(nums1[nums1Mid], nums2[nums2Mid])
	}

	return float64(midLeft+midRight) / 2 // Even number of elements
}

// Max returns the larger of two integers
func Max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// Min returns the smaller of two integers
func Min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	nums1 := []int{1, 3}
	nums2 := []int{2}
	fmt.Println(FindMedianSortedArray(nums1, nums2)) // Output: 2.00000

	nums3 := []int{1, 2}
	nums4 := []int{3, 4}
	fmt.Println(FindMedianSortedArray(nums3, nums4)) // Output: 2.50000
}
```

### Explanation
1. **Initial Setup**: Ensure nums1 is smaller than nums2 to keep the binary search range smaller. We calculate the total middle index k and begin the binary search.
2. **Binary Search**: In each iteration, we partition nums1 and nums2 and check if the partition is valid. We adjust the low and high pointers until we find the correct partition.
3. **Median Calculation**: Once the partition is valid, we compute midLeft and midRight (the two middle elements) and return the median.


### Time and Space Complexity
1. **Time Complexity**: The algorithm runs in O(log(min(m, n))) where m and n are the lengths of the two input arrays. We perform binary search on the smaller array.
2. **Space Complexity**: O(1), as no additional space is required beyond a few variables.


## Conclusion
This solution efficiently solves the problem of finding the median of two sorted arrays in logarithmic time by using binary search, making it suitable for large arrays with different sizes. The algorithm ensures optimal time complexity by focusing on the smaller array in the binary search process.