---
title: Longest Palindromic Substring
description: Solve the "Longest Palindromic Substring" problem efficiently using expand around center technique in Go.
tags: ["leetcode", "golang", "algorithms"]
date: "2024-09-28"
published: true
---

## Problem Statement

Given a string `s`, return the longest palindromic substring in `s`.

### Example 1:
```plaintext
Input: `s = "babad"`
Output: `"bab"`
Explanation: `"aba"` is also a valid answer.
```
### Example 2:

```plaintext
Input: `s = "cbbd"`
Output: `"bb"`
```
### Constraints:

- \( 1 \leq s.length \leq 1000 \)
- `s` consists of only digits and English letters.

## Approach

To find the longest palindromic substring, we can use the **expand around center** technique. The idea is to iterate through each character in the string and treat it as the center of a potential palindrome. Since palindromes can be of both odd and even lengths, we will check for both cases.

### Algorithm

1. **Expand Around Center**: For each character in the string, we expand outwards to check how far we can go while maintaining the palindrome property.
2. **Track the Longest Palindrome**: During each expansion, if we find a longer palindrome than the previously recorded one, we update our longest palindrome substring.


### Flowchart
![Flowchart of Longest Palindromic Substring ](/leetcode/longest_palingdrome.png)

### Implementation in Go

Here is the Go implementation of the solution:

```go
package main

import "fmt"

// longestPalindrome finds the longest palindromic substring in s
func longestPalindrome(s string) string {
	start, end := 0, 0
	for i := 0; i < len(s); i++ {
		// Expand around the center for odd-length palindromes
		len1 := expandAroundCenter(s, i, i)
		// Expand around the center for even-length palindromes
		len2 := expandAroundCenter(s, i, i+1)
		// Choose the longer palindrome
		len := max(len1, len2)
		if len > end-start {
			// Update start and end indices of the longest palindrome found
			start = i - (len-1)/2
			end = i + len/2
		}
	}
	return s[start : end+1]
}

// expandAroundCenter expands around the given center indices and returns the length of the palindrome
func expandAroundCenter(s string, left int, right int) int {
	L, R := left, right
	for L >= 0 && R < len(s) && s[L] == s[R] {
		L--
		R++
	}
	return R - L - 1 // Length of the palindrome
}

// max returns the maximum of two integers
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	s1 := "babad"
	fmt.Println(longestPalindrome(s1)) // Output: "bab" or "aba"

	s2 := "cbbd"
	fmt.Println(longestPalindrome(s2)) // Output: "bb"
}

```

### Explanation
1. **Initialization**: We initialize start and end to track the longest palindrome's indices.
2. **Iterating Through Characters**: For each character in the string, we consider it as a center and attempt to expand outwards for both odd-length and even-length palindromes.
3. **Updating Longest Palindrome**: Whenever we find a longer palindrome than previously recorded, we update the start and end indices to capture the new longest substring.


### Time and Space Complexity
1. **Time Complexity**: O(n^2), where n is the length of the input string. In the worst case, we may need to check all characters and expand around them.
2. **Space Complexity**: O(1), as we are only using a few variables to track indices and lengths.

## Conclusion
This solution effectively finds the longest palindromic substring using the expand around center technique, providing a straightforward approach that balances clarity and efficiency. The algorithm is suitable for input strings of lengths up to 1000, making it efficient for competitive programming and interview scenarios.